# Dikarier Effect System API (v2.6)

[Read in English](README.md) | [日本語で読む](README_JA.md) | [中文阅读](README_ZH.md)

## Введение

Данная документация предназначена для разработчиков, желающих создавать собственные визуальные эффекты (аддоны) или расширять функционал **Dikarier Effect System**.

Плагин предоставляет глобальный интерфейс для манипуляции `PIXI.Container` (экраном игры) и наложения пост-процессинг фильтров на основе состояний (State) или событий.

> **Лицензионное соглашение для разработчиков:**
> Вы имеете право создавать, распространять и продавать собственные аддоны/расширения, использующие данный API.
> Перепродажа или распространение исходного кода самого плагина `Dikarier_EffectSystem.js` запрещена.
> Для работы визуальных эффектов в проекте пользователя должен быть установлен **Dikarier_Core**.

### ⚠️ Критически важно: Соглашение об именовании

Парсер плагина использует строгую фильтрацию тегов для оптимизации производительности.
Чтобы ваш эффект был распознан системой и добавлен в цикл обработки, его имя (тег) **ОБЯЗАНО** соответствовать следующему формату:

` <DikarierEffectName> `

*   Префикс `DikarierEffect` обязателен.
*   Имя должно быть в CamelCase (рекомендуется).
*   Тег должен заканчиваться на `>`.

**Примеры:**
*   ✅ `<DikarierEffectRadiation>` — Корректно. Будет обработано.
*   ❌ `<RadiationEffect>` — Игнорируется (нет префикса).
*   ❌ `<DikarierRadiation>` — Игнорируется (префикс неполный).
*   ❌ `<MyCustomTag>` — Игнорируется.

#### Автоматическая привязка функций
При обработке эффекта система автоматически ищет функцию обновления по имени, производному от тега.
Для тега `<DikarierEffectFire>` система будет искать функцию `updateFireEffect`.

---

## Архитектура и Глобальный Доступ

Весь функционал доступен через глобальное пространство имен `des`. Основной класс управления эффектами находится в `des.mainClass`.

```javascript
// Основной класс системы эффектов
const EffectSystem = des.mainClass;

// Реестр зарегистрированных эффектов
const Registry = des.mainClass.effectRegistry;

// Массив активных эффектов в текущем кадре
const ActiveEffects = des.mainClass.activeEffects;
```

Система работает, перехватывая рендеринг `Scene_Base` и модифицируя свойства `Spriteset_Map` или `Spriteset_Battle` перед отрисовкой кадра.

---

## Структура объекта `effectData`

Каждый активный эффект представлен объектом `effectData`. Этот объект передается в функцию обновления эффекта каждый кадр. Понимание этой структуры критически важно для управления состоянием эффекта.

| Свойство | Тип | Описание |
| :--- | :--- | :--- |
| `id` | `String` | Уникальный идентификатор экземпляра эффекта (генерируется автоматически). |
| `effect` | `String` | Полное имя тега эффекта (например, `<DikarierEffectMyCustom>`). |
| `param` | `Mixed` | Дополнительный параметр. **Важно:** При использовании стандартного парсера тегов `<Tag: X>`, значение `X` интерпретируется как `fadeDuration`, а `param` остается `null` (за исключением эффекта Slow). Для передачи кастомных параметров требуется ручной вызов `applyEffect`. |
| `actor` | `Game_Actor` | Актер, на которого наложен эффект. |
| `stateId` | `Number` | ID состояния в базе данных (если эффект вызван состоянием). |
| `totalDuration` | `Number` | Общая длительность эффекта в кадрах. `Infinity`, если длительность зависит от состояния. |
| `fadeDuration` | `Number` | Длительность фазы появления (Fade In) и затухания (Fade Out) в кадрах. |
| `elapsed` | `Number` | Количество кадров, прошедших с начала эффекта. |
| `intensity` | `Number` | Текущая сила эффекта (от `0.0` до `1.0`). Рассчитывается автоматически системой. |
| `state` | `String` | Текущая фаза: `'fadeIn'`, `'full'`, или `'fadeOut'`. |

---

## Создание и регистрация эффекта

Чтобы добавить новый эффект, необходимо зарегистрировать функцию обновления в `effectRegistry`. Функция вызывается каждый кадр для активного эффекта.

### Сигнатура функции обновления

```javascript
/**
 * @param {Object} screen - Экземпляр PIXI.Container (обычно Spriteset).
 * @param {Object} effectData - Объект данных текущего эффекта.
 * @param {Array} currentFrameFilters - Массив фильтров PIXI для текущего кадра.
 */
function updateMyEffect(screen, effectData, currentFrameFilters) {
    // Логика эффекта
}
```

### Пример реализации

Ниже приведен пример создания эффекта "Underwater" (Под водой), который добавляет волнообразное искажение и синий оттенок.

```javascript
// Регистрация тега эффекта
des.mainClass.effectRegistry['<DikarierEffectUnderwater>'] = function(screen) {
    // Инициализация уникальных свойств контейнера при первом запуске
    screen._underwaterTime = screen._underwaterTime || { time: 0 };
};

// Добавление логики обновления.
// Имя функции должно соответствовать паттерну: update + ИмяЭффекта + Effect
des.mainClass.updateUnderwaterEffect = function(screen, effectData, currentFrameFilters) {
    // Получаем глобальное время эффектов для синхронизации анимаций
    const time = des.mainClass.effectTime * 0.05;
    
    // Получаем рассчитанную интенсивность (учитывает fade in/out)
    const intensity = effectData.intensity;

    // Применяем трансформацию экрана (покачивание)
    // Используем pivot для вращения/масштабирования от центра, если нужно
    const waveY = Math.sin(time) * 10 * intensity;
    screen.y += waveY;

    // Работа с фильтрами
    if (intensity > 0) {
        // Создаем новый экземпляр фильтра для текущего кадра
        // ВАЖНО: Не модифицируйте screen.filters напрямую, используйте массив currentFrameFilters
        const colorFilter = new PIXI.filters.ColorMatrixFilter();
        
        // Смещаем оттенок в синюю сторону (180 градусов - циан/синий)
        colorFilter.hue(180 * intensity, false);
        
        // Добавляем фильтр в стек рендеринга этого кадра
        currentFrameFilters.push(colorFilter);
        
        // Можно добавить дополнительные фильтры, например Blur
        if (intensity > 0.5) {
             const blur = new PIXI.filters.BlurFilter();
             blur.blur = (intensity - 0.5) * 4;
             currentFrameFilters.push(blur);
        }
    }
};
```

---

## Нюансы парсинга и параметры

Система использует встроенный парсер заметок (Notetags), который имеет специфическое поведение при обработке аргументов.

1.  **Стандартный формат:** `<DikarierEffectName>`
    *   `param`: `null`
    *   `fadeDuration`: значение по умолчанию (180 кадров).
2.  **Формат с аргументом:** `<DikarierEffectName: 60>`
    *   **Внимание:** Число после двоеточия парсер автоматически интерпретирует как `fadeDuration` (в секундах), а не как произвольный параметр.
    *   `param`: `null`
    *   `fadeDuration`: 60 секунд.
3.  **Исключение (Slow):** `<DikarierEffectSlow: 0.5>`
    *   Для этого эффекта написан специальный regex.
    *   `param`: `0.5`
    *   `fadeDuration`: значение по умолчанию.

**Для передачи кастомных параметров в ваш эффект:**
Не полагайтесь на автоматический парсинг заметок, если вам нужно передать число, отличное от времени фейда. Вместо этого используйте вызов API:

```javascript
// Ручной запуск эффекта с кастомным параметром
const durationSec = 10;
const fadeSec = 2;
const customParam = 42; // Ваше значение

des.mainClass.applyEffect(
    '<DikarierEffectMyCustom>', 
    customParam, 
    fadeSec, 
    durationSec, 
    $gameParty.leader(), 
    null // stateId, если применимо
);
```

Внутри `updateMyEffect`, вы сможете прочитать `effectData.param` (равный 42).

---

## Работа с PIXI.js и Трансформациями

При работе с объектом `screen` (наследуется от `PIXI.Container`), соблюдайте следующие правила для обеспечения совместимости и производительности.

### 1. Трансформации (Transform)
В каждом кадре плагин сбрасывает основные параметры трансформации (`x`, `y`, `scale`, `rotation`, `skew`) перед вызовом функций обновления. Это означает, что эффекты **аддитивны** внутри одного кадра, но не накапливаются между кадрами (stateless rendering).

*   **Корректно:** `screen.x += 10;` (Сдвигает экран на 10 пикселей в текущем кадре).
*   **Бесполезно:** `screen.x = screen.x + 1;` (Как инкремент счетчика — не сработает, так как `x` сбрасывается).

### 2. Фильтры (Filters)
Система очищает `screen.filters` каждый кадр и пересобирает их на основе массива `pluginFilters` (он же `currentFrameFilters`).

*   **Всегда создавайте новые экземпляры фильтров** или используйте пул объектов.
*   **Производительность:** `PIXI.filters.BlurFilter` и `ColorMatrixFilter` относительно дешевы. `NoiseFilter` или сверточные фильтры могут сильно просадить FPS на слабых устройствах.

### 3. Критическое предупреждение: Alpha Channel
**Строго не рекомендуется** использовать `ColorMatrixFilter` для изменения альфа-канала (прозрачности) всего контейнера `alpha`.

```javascript
// НИКОГДА ТАК НЕ ДЕЛАЙТЕ В ЦВЕТОВОЙ МАТРИЦЕ
matrix[18] = 0.5; // Установка альфы
```

**Причина:** `screen` содержит не только тайлы карты, но и спрайты событий, игрока и иногда параллакс. Изменение альфы через матрицу приведет к тому, что черные/прозрачные пиксели могут начать просвечивать "сквозь" слои, либо события станут полупрозрачными, открывая задний фон карты некорректно. Используйте `brightness` (яркость) или `tint` (оттенок) для затемнения.

---

## Управление жизненным циклом

### `intensity` (Интенсивность)
Это свойство автоматически рассчитывается ядром.
*   **Fade In:** Растет от 0 до 1.
*   **Full:** Держится на 1.
*   **Fade Out:** Падает от 1 до 0.

Используйте `intensity` как множитель для всех ваших визуальных манипуляций.

```javascript
// Плавное включение/выключение эффекта
const shakePower = 5 * effectData.intensity; 
```

### Принудительная остановка
Если вы хотите прервать эффект досрочно:

```javascript
// Переводит эффект в стадию Fade Out
des.mainClass.clearEffect('<DikarierEffectMyCustom>'); 
```

---

## Доступ к API (PRO особенности)

Хотя API открыт, функции привязки эффектов к картам (`MapEffect`) и экипировке (`ItemEffect`) работают через класс `EffectUtils`, который зависит от инициализации в `Dikarier_Core`. При разработке аддонов проверяйте наличие необходимых методов, если вы используете эти специфические привязки.

Для обычной работы через состояния (States) дополнительных проверок не требуется.
